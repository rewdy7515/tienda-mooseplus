<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Recordatorios</title>
    <link rel="stylesheet" href="../../styles/styles.css" />
    <style>
      .recordatorios-wrap {
        max-width: 960px;
        margin: 0 auto;
        padding: 16px;
      }
      .rec-buttons {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        margin: 12px 0;
      }
      .rec-buttons button {
        padding: 10px 14px;
        border: none;
        border-radius: 10px;
        background: #111;
        color: #fff;
        cursor: pointer;
        font-weight: 700;
      }
      .rec-results {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-top: 12px;
      }
      .rec-card {
        padding: 12px;
        border: 1px solid #e5e7eb;
        border-radius: 10px;
        background: #fff;
        text-align: left;
        cursor: pointer;
        transition: box-shadow 0.2s ease, transform 0.2s ease;
      }
      .rec-card:hover {
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.08);
        transform: translateY(-1px);
      }
      .rec-card:disabled {
        cursor: default;
        opacity: 0.72;
        transform: none;
      }
      .rec-card h4 {
        margin: 0 0 6px;
        font-size: 15px;
      }
      .rec-card p {
        margin: 2px 0;
        font-size: 13px;
        color: #333;
      }
      .rec-card pre {
        margin: 0;
        white-space: pre-wrap;
        font-family: "Inter", system-ui, -apple-system, sans-serif;
      }
      .status {
        margin-top: 8px;
      }
    </style>
  </head>
  <body>
    <div id="app-header" data-header-root="../../" data-header-pages="../"></div>
    <script src="../../scripts/header-loader.js"></script>

    <main class="categorias-dinamicas">
      <div class="recordatorios-wrap">
        <h2>Recordatorios</h2>
        <div class="rec-buttons">
          <button type="button" id="btn-generar-recordatorios">
            Generar recordatorios
          </button>
        </div>
        <div id="rec-status" class="status"></div>
        <div id="rec-results" class="rec-results"></div>
      </div>
    </main>
    <script type="module">
      import { requireSession, attachLogoHome } from "../../scripts/session.js";
      import { supabase } from "../../scripts/api.js";
      import { formatDDMMYYYY } from "../../scripts/date-format.js";

      requireSession();
      attachLogoHome();

      const btnGenerarRecordatorios = document.querySelector(
        "#btn-generar-recordatorios",
      );
      const statusEl = document.querySelector("#rec-status");
      const resultsEl = document.querySelector("#rec-results");

      const setStatus = (msg) => {
        if (statusEl) statusEl.textContent = msg || "";
      };
      const SEND_DELAY_MIN_MS = 8000;
      const SEND_DELAY_MAX_MS = 15000;

      const getCaracasDateStr = (offsetDays = 0) => {
        const now = new Date();
        const parts = new Intl.DateTimeFormat("en-CA", {
          timeZone: "America/Caracas",
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
        }).formatToParts(now);
        const year = Number(parts.find((p) => p.type === "year")?.value || 0);
        const month = Number(parts.find((p) => p.type === "month")?.value || 0);
        const day = Number(parts.find((p) => p.type === "day")?.value || 0);
        const base = new Date(Date.UTC(year, month - 1, day));
        base.setUTCDate(base.getUTCDate() + offsetDays);
        return base.toISOString().slice(0, 10);
      };

      const copyToClipboard = async (text) => {
        try {
          await navigator.clipboard.writeText(text);
        } catch (_) {
          const ta = document.createElement("textarea");
          ta.value = text;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand("copy");
          ta.remove();
        }
      };

      const sleep = (ms) =>
        new Promise((resolve) => {
          setTimeout(resolve, ms);
        });

      const randomSendDelayMs = () =>
        SEND_DELAY_MIN_MS +
        Math.floor(Math.random() * (SEND_DELAY_MAX_MS - SEND_DELAY_MIN_MS + 1));

      const sendWhatsappRecordatorio = async ({ phone, message, ventaIds = [] }) => {
        const resp = await fetch("/api/whatsapp/send-recordatorio", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ phone, message, ventaIds }),
        });
        let body = null;
        try {
          body = await resp.json();
        } catch (_) {
          body = null;
        }
        if (!resp.ok) {
          throw new Error(body?.error || `HTTP ${resp.status}`);
        }
        return body;
      };

      const ensureWhatsappReady = async () => {
        const resp = await fetch("/api/whatsapp/status");
        let body = null;
        try {
          body = await resp.json();
        } catch (_) {
          body = null;
        }
        if (!resp.ok || !body?.ready) {
          throw new Error(body?.error || "WhatsApp no est√° listo");
        }
      };

      const sendGeneratedMessages = async (messages = []) => {
        await ensureWhatsappReady();
        let sent = 0;
        let failed = 0;
        let skippedNoPhone = 0;
        let updatedVentas = 0;
        const sendableCount = (messages || []).filter((msg) =>
          Boolean(String(msg?.telefono || "").trim()),
        ).length;
        let sendableProcessed = 0;

        for (const msg of messages || []) {
          const phone = String(msg.telefono || "").trim();
          if (!phone) {
            skippedNoPhone += 1;
            continue;
          }
          try {
            const resp = await sendWhatsappRecordatorio({
              phone,
              message: msg.plain,
              ventaIds: msg.ventaIds || [],
            });
            sent += 1;
            updatedVentas += Number(resp?.updatedVentas || 0);
          } catch (err) {
            failed += 1;
            console.error("recordatorios send error", {
              idUsuario: msg.idUsuario,
              phone,
              error: err,
            });
          }

          sendableProcessed += 1;
          if (sendableProcessed < sendableCount) {
            const delayMs = randomSendDelayMs();
            await sleep(delayMs);
          }
        }

        return { total: messages.length, sent, failed, skippedNoPhone, updatedVentas };
      };

      const renderCards = (items) => {
        if (!resultsEl) return;
        if (!items.length) {
          resultsEl.innerHTML = "";
          return;
        }
        resultsEl.innerHTML = items
          .map(
            (msg) => `
              <button
                class="rec-card"
                type="button"
                data-copy="${encodeURIComponent(msg.plain)}"
              >
                ${msg.html}
              </button>
            `
          )
          .join("");
        resultsEl.querySelectorAll(".rec-card").forEach((btn) => {
          btn.addEventListener("click", async () => {
            const txt = btn.dataset.copy ? decodeURIComponent(btn.dataset.copy) : "";
            if (!txt) return;
            try {
              await copyToClipboard(txt);
              setStatus("Mensaje copiado.");
            } catch (err) {
              console.error("copiar recordatorios error", err);
              setStatus("No se pudo copiar el mensaje.");
            }
          });
        });
      };

      const buildMessagesFromGrouped = (grouped) =>
        Object.values(grouped || {}).map((g) => {
          const bloques = Object.values(g.plataformas || {})
            .map((plat) => {
              const detalles = (plat.detalles || []).join("\n\n");
              return `*${plat.nombre || "-"}*\n${detalles}`;
            })
            .join("\n\n");
          const plain = `¬°Hola ${g.cliente}! ‚ù§Ô∏èü´é\nRecuerda actualizar el pago de tu membres√≠a:\n\n${bloques}\n\nRenueva ahora para seguir disfrutando de nuestros servicios sin interrupciones üîÅ‚ú®`;
          const html = `<h4>${g.cliente || "Cliente"}</h4><p>Tel√©fono: ${g.telefono || "-"}</p><pre>${plain}</pre>`;
          const ventaIds = Array.from(
            new Set(
              (g.ventaIds || [])
                .map((id) => Number(id))
                .filter((id) => Number.isFinite(id) && id > 0),
            ),
          );
          return {
            idUsuario: g.idUsuario || null,
            cliente: g.cliente || "Cliente",
            telefono: g.telefono || "",
            html,
            plain,
            ventaIds,
          };
        });

      const fetchMessages = async () => {
        const fechaManana = getCaracasDateStr(1);
        const { data: ventas, error: ventErr } = await supabase
          .from("ventas")
          .select(
            "id_usuario, id_cuenta, id_precio, id_venta, id_perfil, fecha_corte, correo_miembro, recordatorio_enviado",
          )
          .lte("fecha_corte", fechaManana)
          .or("recordatorio_enviado.eq.false,recordatorio_enviado.is.null");
        if (ventErr) throw ventErr;

          const cuentasIds = Array.from(new Set((ventas || []).map((v) => v.id_cuenta).filter(Boolean)));
          const precioIds = Array.from(new Set((ventas || []).map((v) => v.id_precio).filter(Boolean)));
          const userIds = Array.from(new Set((ventas || []).map((v) => v.id_usuario).filter(Boolean)));
          const perfilIds = Array.from(new Set((ventas || []).map((v) => v.id_perfil).filter(Boolean)));

          const [
            { data: cuentas, error: cErr },
            { data: precios, error: pErr },
            { data: users, error: uErr },
            { data: perfiles, error: perfErr },
          ] = await Promise.all([
            cuentasIds.length
              ? supabase.from("cuentas").select("id_cuenta, correo, id_plataforma").in("id_cuenta", cuentasIds)
              : Promise.resolve({ data: [], error: null }),
            precioIds.length
              ? supabase.from("precios").select("id_precio, id_plataforma").in("id_precio", precioIds)
              : Promise.resolve({ data: [], error: null }),
            userIds.length
              ? supabase
                  .from("usuarios")
                  .select("id_usuario, nombre, apellido, telefono")
                  .in("id_usuario", userIds)
              : Promise.resolve({ data: [], error: null }),
            perfilIds.length
              ? supabase.from("perfiles").select("id_perfil, n_perfil, perfil_hogar").in("id_perfil", perfilIds)
              : Promise.resolve({ data: [], error: null }),
          ]);
          if (cErr) throw cErr;
          if (pErr) throw pErr;
          if (uErr) throw uErr;
          if (perfErr) throw perfErr;

          const platIds = Array.from(
            new Set([
              ...(cuentas || []).map((c) => c.id_plataforma).filter(Boolean),
              ...(precios || []).map((p) => p.id_plataforma).filter(Boolean),
            ])
          );
          const { data: plats, error: platErr } = platIds.length
            ? await supabase
                .from("plataformas")
                .select("id_plataforma, nombre, correo_cliente")
                .in("id_plataforma", platIds)
            : { data: [], error: null };
          if (platErr) throw platErr;

          const mapCuenta = (cuentas || []).reduce((acc, c) => {
            acc[c.id_cuenta] = c;
            return acc;
          }, {});
          const mapPrecio = (precios || []).reduce((acc, p) => {
            acc[p.id_precio] = p;
            return acc;
          }, {});
          const mapPlat = (plats || []).reduce((acc, p) => {
            acc[p.id_plataforma] = p;
            return acc;
          }, {});
          const mapUser = (users || []).reduce((acc, u) => {
            acc[u.id_usuario] = {
              cliente:
                [u.nombre, u.apellido].filter(Boolean).join(" ").trim() ||
                `Usuario ${u.id_usuario}`,
              telefono: String(u.telefono || "").trim(),
            };
            return acc;
          }, {});
          const mapPerf = (perfiles || []).reduce((acc, p) => {
            acc[p.id_perfil] = { n: p.n_perfil, hogar: p.perfil_hogar === true };
            return acc;
          }, {});

          // Construir mensajes agrupados por usuario y por plataforma
          const grouped = (ventas || []).reduce((acc, v) => {
            const cuenta = mapCuenta[v.id_cuenta] || {};
            const precio = mapPrecio[v.id_precio] || {};
            const platId = cuenta.id_plataforma || precio.id_plataforma || null;
            const platInfo = platId ? mapPlat[platId] || {} : {};
            const platNombre = platId ? platInfo.nombre || `Plataforma ${platId}` : "-";
            const userInfo = mapUser[v.id_usuario] || {};
            const cliente = userInfo.cliente || "Cliente";
            const telefono = userInfo.telefono || "";
            const useCorreoCliente =
              platInfo.correo_cliente === true ||
              platInfo.correo_cliente === "true" ||
              platInfo.correo_cliente === "1";
            const correo = useCorreoCliente ? v.correo_miembro || "-" : cuenta.correo || "-";
            const perfInfo = v.id_perfil ? mapPerf[v.id_perfil] : null;
            const showPerfil = Number(platId) !== 9;
            const perfilTxt = showPerfil && perfInfo?.n ? `Perfil: M${perfInfo.n}` : "";
            const isNetflix = platId === 1;
            const isPlan2Precio = v.id_precio === 4 || v.id_precio === 5;
            const isNetflixPlan2 = isNetflix && (isPlan2Precio || perfInfo?.hogar);
            const hogarTxt = isNetflixPlan2 ? " (HOGAR ACTUALIZADO)" : "";
            const key = v.id_usuario || "sin_usuario";
            if (!acc[key]) {
              acc[key] = { idUsuario: v.id_usuario || null, cliente, telefono, plataformas: {}, ventaIds: [] };
            }
            const platDisplayName = `${platNombre}${hogarTxt}`;
            const platformKey = `${String(platId || platNombre || "-")}::${hogarTxt ? "hogar" : "normal"}`;
            if (!acc[key].plataformas[platformKey]) {
              acc[key].plataformas[platformKey] = {
                nombre: platDisplayName,
                detalles: [],
              };
            }
            if (v.id_venta) acc[key].ventaIds.push(v.id_venta);
            const fechaPago = v.fecha_corte ? formatDDMMYYYY(v.fecha_corte) : "-";
            acc[key].plataformas[platformKey].detalles.push(
              `\`ID VENTA: #${v.id_venta}\`
Correo: ${correo}
${perfilTxt ? `${perfilTxt}\n` : ""}Fecha de pago: ${fechaPago}`
            );
          return acc;
        }, {});

        const messages = buildMessagesFromGrouped(grouped);
        return { messages, grouped };
      };

      const loadRecordatorios = async () => {
        setStatus("Generando recordatorios...");
        resultsEl.innerHTML = "";
        if (btnGenerarRecordatorios) btnGenerarRecordatorios.disabled = true;
        try {
          const { messages } = await fetchMessages();
          renderCards(messages);
          if (!messages.length) {
            setStatus("Sin resultados.");
            return;
          }

          setStatus(`Enviando ${messages.length} recordatorio(s) por WhatsApp...`);
          const stats = await sendGeneratedMessages(messages);
          setStatus(
            `Proceso completado. Enviados: ${stats.sent}, sin tel√©fono: ${stats.skippedNoPhone}, fallidos: ${stats.failed}, ventas marcadas: ${stats.updatedVentas}.`,
          );
        } catch (err) {
          console.error("recordatorios generar error", err);
          setStatus(err?.message || "No se pudieron generar los recordatorios.");
        } finally {
          if (btnGenerarRecordatorios) btnGenerarRecordatorios.disabled = false;
        }
      };

      btnGenerarRecordatorios?.addEventListener("click", loadRecordatorios);
    </script>
  </body>
</html>
