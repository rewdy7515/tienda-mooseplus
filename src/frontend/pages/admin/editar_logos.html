<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Editar logos</title>
    <link rel="stylesheet" href="../../styles/styles.css" />
    <style>
      .logos-wrapper {
        display: flex;
        flex-direction: column;
        gap: 16px;
        width: 100%;
        max-width: 820px;
      }
      .logos-field {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .logos-field select {
        padding: 8px 10px;
        border: 1px solid #d1d5db;
        border-radius: 10px;
        font-size: 14px;
      }
      .logo-editor {
        display: flex;
        gap: 20px;
        align-items: stretch;
      }
      .logo-editor.hidden {
        display: none;
      }
      .logo-editor.no-logo .logo-current {
        display: none;
      }
      .logo-editor.no-banner .banner-current {
        display: none;
      }
      .logo-editor.no-preview .preview-current {
        display: none;
      }
      .logo-current {
        flex: 1;
        background: #fff;
        border: 1px solid #e5e7eb;
        border-radius: 14px;
        padding: 14px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .logo-frame {
        width: 100%;
        height: 160px;
        border: 1px dashed #d1d5db;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        background: #fafafa;
      }
      .banner-frame {
        width: 100%;
        aspect-ratio: 3 / 1;
        min-height: 120px;
        border: 1px dashed #d1d5db;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        background: #fafafa;
      }
      .logo-frame img {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
      }
      .banner-frame img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      .logo-upload {
        flex: 1;
        background: #fff;
        border: 1px solid #e5e7eb;
        border-radius: 14px;
        padding: 14px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .logo-label {
        font-weight: 700;
        margin: 0;
        color: #111;
      }
      .logo-upload input[type="file"] {
        padding: 6px 0;
      }
      .logo-status {
        margin: 0;
      }
      .preview-section {
        margin-top: 10px;
      }
      .preview-toggle {
        width: 100%;
      }
      .iconos-gallery {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(96px, 1fr));
        gap: 10px;
        width: 100%;
        max-height: 360px;
        overflow: auto;
        padding-right: 4px;
      }
      .icono-item {
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .icono-item img {
        width: 100%;
        aspect-ratio: 1 / 1;
        object-fit: cover;
        border-radius: 10px;
        border: 1px solid #e5e7eb;
        background: #f9fafb;
      }
      .icono-item figcaption {
        font-size: 11px;
        color: #4b5563;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .icono-empty {
        margin: 0;
      }
      @media (max-width: 720px) {
        .logo-editor {
          flex-direction: column;
        }
      }
    </style>
  </head>
  <body>
    <div id="app-header" data-header-root="../../" data-header-pages="../"></div>
    <script src="../../scripts/header-loader.js"></script>

    <main class="categorias-dinamicas">
      <h2>Editar logos</h2>
      <div class="logos-wrapper">
        <div class="logos-field">
          <label for="logo-plataforma"><strong>Plataforma</strong></label>
          <select id="logo-plataforma">
            <option value="">Seleccione una plataforma</option>
          </select>
        </div>

        <div id="logo-editor" class="logo-editor hidden">
          <div class="logo-current" id="logo-current">
            <p class="logo-label">Logo actual</p>
            <div class="logo-frame">
              <img id="logo-preview" src="" alt="Logo actual" />
            </div>
          </div>
          <div class="logo-upload">
            <p class="logo-label">Nuevo logo</p>
            <input type="file" id="logo-file" accept="image/*" />
            <button type="button" class="btn-primary" id="btn-logo-update">
              Actualizar logo
            </button>
            <p id="logo-status" class="status logo-status"></p>
          </div>
        </div>

        <div id="banner-editor" class="logo-editor hidden">
          <div class="logo-current banner-current" id="banner-current">
            <p class="logo-label">Banner actual</p>
            <div class="banner-frame">
              <img id="banner-preview" src="" alt="Banner actual" />
            </div>
          </div>
          <div class="logo-upload">
            <p class="logo-label">Nuevo banner</p>
            <input type="file" id="banner-file" accept="image/*" />
            <button type="button" class="btn-primary" id="btn-banner-update">
              Actualizar banner
            </button>
            <p id="banner-status" class="status logo-status"></p>
          </div>
        </div>

        <div class="preview-section">
          <button type="button" class="btn-outline preview-toggle" id="btn-preview-toggle">
            Editar preview
          </button>
          <div id="preview-editor" class="logo-editor hidden">
            <div class="logo-current preview-current" id="preview-current">
              <p class="logo-label">Preview actual</p>
              <div class="banner-frame">
                <img id="preview-image" src="" alt="Preview actual" />
              </div>
            </div>
            <div class="logo-upload">
              <p class="logo-label">Nuevo preview</p>
              <input type="file" id="preview-file" accept="image/*" />
              <button type="button" class="btn-primary" id="btn-preview-update">
                Subir preview
              </button>
              <p id="preview-status" class="status logo-status"></p>
            </div>
          </div>
        </div>

        <div class="preview-section">
          <button type="button" class="btn-outline preview-toggle" id="btn-iconos-toggle">
            Editar iconos
          </button>
          <div id="iconos-editor" class="logo-editor hidden">
            <div class="logo-upload">
              <p class="logo-label">Importar iconos (carpeta o múltiples)</p>
              <input
                type="file"
                id="iconos-files"
                accept="image/*"
                multiple
                webkitdirectory
                directory
              />
              <button type="button" class="btn-primary" id="btn-iconos-upload">
                Subir iconos
              </button>
              <p id="iconos-status" class="status logo-status"></p>
            </div>
            <div class="logo-current">
              <p class="logo-label">Iconos en public_assets/icono-perfil</p>
              <div id="iconos-gallery" class="iconos-gallery">
                <p class="status icono-empty">Sin iconos cargados.</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </main>

    <script type="module">
      import { requireSession, attachLogout, attachLogoHome } from "../../scripts/session.js";
      import {
        API_BASE,
        clearServerSession,
        loadCurrentUser,
        supabase,
        uploadPlatformLogos,
        startSession,
      } from "../../scripts/api.js";

      const sessionId = requireSession();
      console.log("[editar_logos] location", window.location.href);
      console.log("[editar_logos] online", navigator?.onLine);
      console.log("[editar_logos] sessionId", sessionId);
      attachLogoHome();

      const usernameEl = document.querySelector(".username");
      const adminLink = document.querySelector(".admin-link");
      const isTrue = (v) => v === true || v === 1 || v === "1" || v === "true" || v === "t";

      const selectPlataforma = document.querySelector("#logo-plataforma");
      const editor = document.querySelector("#logo-editor");
      const bannerEditor = document.querySelector("#banner-editor");
      const currentWrap = document.querySelector("#logo-current");
      const previewImg = document.querySelector("#logo-preview");
      const fileInput = document.querySelector("#logo-file");
      const btnUpdate = document.querySelector("#btn-logo-update");
      const statusEl = document.querySelector("#logo-status");
      const bannerCurrentWrap = document.querySelector("#banner-current");
      const bannerPreview = document.querySelector("#banner-preview");
      const bannerInput = document.querySelector("#banner-file");
      const btnBannerUpdate = document.querySelector("#btn-banner-update");
      const bannerStatusEl = document.querySelector("#banner-status");
      const previewToggleBtn = document.querySelector("#btn-preview-toggle");
      const previewEditor = document.querySelector("#preview-editor");
      const previewCurrentWrap = document.querySelector("#preview-current");
      const previewPageImg = document.querySelector("#preview-image");
      const previewInput = document.querySelector("#preview-file");
      const btnPreviewUpdate = document.querySelector("#btn-preview-update");
      const previewStatusEl = document.querySelector("#preview-status");
      const iconosToggleBtn = document.querySelector("#btn-iconos-toggle");
      const iconosEditor = document.querySelector("#iconos-editor");
      const iconosFilesInput = document.querySelector("#iconos-files");
      const btnIconosUpload = document.querySelector("#btn-iconos-upload");
      const iconosStatusEl = document.querySelector("#iconos-status");
      const iconosGalleryEl = document.querySelector("#iconos-gallery");

      let plataformasMap = {};
      let selectedId = null;
      let paginaPreview = null;

      const setStatus = (msg, isError = false) => {
        if (!statusEl) return;
        statusEl.textContent = msg || "";
        statusEl.classList.toggle("is-error", isError);
        statusEl.classList.toggle("is-success", !isError && !!msg);
      };

      const setBannerStatus = (msg, isError = false) => {
        if (!bannerStatusEl) return;
        bannerStatusEl.textContent = msg || "";
        bannerStatusEl.classList.toggle("is-error", isError);
        bannerStatusEl.classList.toggle("is-success", !isError && !!msg);
      };

      const setPreviewStatus = (msg, isError = false) => {
        if (!previewStatusEl) return;
        previewStatusEl.textContent = msg || "";
        previewStatusEl.classList.toggle("is-error", isError);
        previewStatusEl.classList.toggle("is-success", !isError && !!msg);
      };

      const setIconosStatus = (msg, isError = false) => {
        if (!iconosStatusEl) return;
        iconosStatusEl.textContent = msg || "";
        iconosStatusEl.classList.toggle("is-error", isError);
        iconosStatusEl.classList.toggle("is-success", !isError && !!msg);
      };

      const escapeHtml = (value) =>
        String(value ?? "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");

      const isImageFile = (file) => {
        if (!file) return false;
        if (String(file.type || "").startsWith("image/")) return true;
        return /\.(png|jpe?g|webp|gif|bmp|svg|avif)$/i.test(String(file.name || ""));
      };

      const isImageName = (name) => /\.(png|jpe?g|webp|gif|bmp|svg|avif)$/i.test(String(name || ""));

      // Exporta a 3x para mejor nitidez en el display 148x185
      const resizeImageIfNeeded = (file, targetW = 444, targetH = 555, maxBytes = 150000) => {
        return new Promise((resolve, reject) => {
          if (!file || !file.type?.startsWith("image/")) return resolve(file);
          const shouldResize = file.size > maxBytes;
          const img = new Image();
          const url = URL.createObjectURL(file);
          img.onload = () => {
            URL.revokeObjectURL(url);
            const { width, height } = img;
            if (!shouldResize && width === targetW && height === targetH) {
              resolve(file);
              return;
            }
            const canvas = document.createElement("canvas");
            canvas.width = targetW;
            canvas.height = targetH;
            const ctx = canvas.getContext("2d");
            if (!ctx) {
              resolve(file);
              return;
            }
            // Contener imagen dentro del tamaño objetivo manteniendo proporción
            const scale = Math.min(targetW / width, targetH / height);
            const drawW = Math.max(1, Math.round(width * scale));
            const drawH = Math.max(1, Math.round(height * scale));
            const offsetX = Math.round((targetW - drawW) / 2);
            const offsetY = Math.round((targetH - drawH) / 2);
            ctx.clearRect(0, 0, targetW, targetH);
            ctx.drawImage(img, offsetX, offsetY, drawW, drawH);
            const tryWebp = true;
            const mime = tryWebp ? "image/webp" : "image/jpeg";
            const makeBlob = (type, quality) =>
              new Promise((res) => {
                canvas.toBlob((blob) => res(blob), type, quality);
              });
            (async () => {
              let quality = 0.92;
              let blob = await makeBlob(mime, quality);
              while (blob && blob.size > maxBytes && quality > 0.7) {
                quality = Math.max(0.7, quality - 0.05);
                blob = await makeBlob(mime, quality);
              }
              if (blob) {
                const baseName = file.name.replace(/\.[^.]+$/, "");
                const ext = blob.type === "image/webp" ? "webp" : "jpg";
                const resized = new File([blob], `${baseName}.${ext}`, { type: blob.type });
                resolve(resized);
                return;
              }
              // Fallback a JPEG si WebP no está soportado
              let jpegQuality = 0.9;
              let jpegBlob = await makeBlob("image/jpeg", jpegQuality);
              while (jpegBlob && jpegBlob.size > maxBytes && jpegQuality > 0.7) {
                jpegQuality = Math.max(0.7, jpegQuality - 0.05);
                jpegBlob = await makeBlob("image/jpeg", jpegQuality);
              }
              if (!jpegBlob) {
                resolve(file);
                return;
              }
              const baseName = file.name.replace(/\.[^.]+$/, "");
              const resized = new File([jpegBlob], `${baseName}.jpg`, { type: jpegBlob.type });
              resolve(resized);
            })().catch(() => resolve(file));
          };
          img.onerror = () => {
            URL.revokeObjectURL(url);
            resolve(file);
          };
          img.src = url;
        });
      };

      // Banner 3x para 275x138 aprox (825x414)
      const resizeBannerIfNeeded = (file, targetW = 825, targetH = 414, maxBytes = 220000) => {
        return new Promise((resolve) => {
          if (!file || !file.type?.startsWith("image/")) return resolve(file);
          const shouldResize = file.size > maxBytes;
          const img = new Image();
          const url = URL.createObjectURL(file);
          img.onload = () => {
            URL.revokeObjectURL(url);
            const { width, height } = img;
            if (!shouldResize && width === targetW && height === targetH) {
              resolve(file);
              return;
            }
            const canvas = document.createElement("canvas");
            canvas.width = targetW;
            canvas.height = targetH;
            const ctx = canvas.getContext("2d");
            if (!ctx) {
              resolve(file);
              return;
            }
            const scale = Math.max(targetW / width, targetH / height);
            const drawW = Math.max(1, Math.round(width * scale));
            const drawH = Math.max(1, Math.round(height * scale));
            const offsetX = Math.round((targetW - drawW) / 2);
            const offsetY = Math.round((targetH - drawH) / 2);
            ctx.clearRect(0, 0, targetW, targetH);
            ctx.drawImage(img, offsetX, offsetY, drawW, drawH);
            const tryWebp = true;
            const mime = tryWebp ? "image/webp" : "image/jpeg";
            const makeBlob = (type, quality) =>
              new Promise((res) => {
                canvas.toBlob((blob) => res(blob), type, quality);
              });
            (async () => {
              let quality = 0.92;
              let blob = await makeBlob(mime, quality);
              while (blob && blob.size > maxBytes && quality > 0.7) {
                quality = Math.max(0.7, quality - 0.05);
                blob = await makeBlob(mime, quality);
              }
              if (blob) {
                const baseName = file.name.replace(/\.[^.]+$/, "");
                const ext = blob.type === "image/webp" ? "webp" : "jpg";
                const resized = new File([blob], `${baseName}.${ext}`, { type: blob.type });
                resolve(resized);
                return;
              }
              resolve(file);
            })().catch(() => resolve(file));
          };
          img.onerror = () => {
            URL.revokeObjectURL(url);
            resolve(file);
          };
          img.src = url;
        });
      };

      const resizePreviewIfNeeded = (file, targetW = 1200, targetH = 630, maxBytes = 280000) => {
        return new Promise((resolve) => {
          if (!file || !file.type?.startsWith("image/")) return resolve(file);
          const shouldResize = file.size > maxBytes;
          const img = new Image();
          const url = URL.createObjectURL(file);
          img.onload = () => {
            URL.revokeObjectURL(url);
            const { width, height } = img;
            if (!shouldResize && width === targetW && height === targetH) {
              resolve(file);
              return;
            }
            const canvas = document.createElement("canvas");
            canvas.width = targetW;
            canvas.height = targetH;
            const ctx = canvas.getContext("2d");
            if (!ctx) {
              resolve(file);
              return;
            }
            const scale = Math.max(targetW / width, targetH / height);
            const drawW = Math.max(1, Math.round(width * scale));
            const drawH = Math.max(1, Math.round(height * scale));
            const offsetX = Math.round((targetW - drawW) / 2);
            const offsetY = Math.round((targetH - drawH) / 2);
            ctx.clearRect(0, 0, targetW, targetH);
            ctx.drawImage(img, offsetX, offsetY, drawW, drawH);
            const makeBlob = (type, quality) =>
              new Promise((res) => {
                canvas.toBlob((blob) => res(blob), type, quality);
              });
            (async () => {
              let quality = 0.92;
              let blob = await makeBlob("image/jpeg", quality);
              while (blob && blob.size > maxBytes && quality > 0.7) {
                quality = Math.max(0.7, quality - 0.05);
                blob = await makeBlob("image/jpeg", quality);
              }
              if (!blob) {
                resolve(file);
                return;
              }
              const baseName = file.name.replace(/\.[^.]+$/, "");
              const resized = new File([blob], `${baseName}.jpg`, { type: blob.type });
              resolve(resized);
            })().catch(() => resolve(file));
          };
          img.onerror = () => {
            URL.revokeObjectURL(url);
            resolve(file);
          };
          img.src = url;
        });
      };

      const renderEditor = (plat) => {
        if (!editor) return;
        if (!plat) {
          editor.classList.add("hidden");
          bannerEditor?.classList.add("hidden");
          return;
        }
        editor.classList.remove("hidden");
        const hasLogo = !!plat.imagen;
        editor.classList.toggle("no-logo", !hasLogo);
        if (currentWrap) currentWrap.style.display = hasLogo ? "flex" : "none";
        if (previewImg) previewImg.src = hasLogo ? plat.imagen : "";

        if (bannerEditor) {
          bannerEditor.classList.remove("hidden");
          const hasBanner = !!plat.banner;
          bannerEditor.classList.toggle("no-banner", !hasBanner);
          if (bannerCurrentWrap) bannerCurrentWrap.style.display = hasBanner ? "flex" : "none";
          if (bannerPreview) bannerPreview.src = hasBanner ? plat.banner : "";
        }
      };

      const renderPreview = () => {
        if (!previewEditor) return;
        const hasPreview = !!paginaPreview?.preview;
        previewEditor.classList.toggle("no-preview", !hasPreview);
        if (previewCurrentWrap) previewCurrentWrap.style.display = hasPreview ? "flex" : "none";
        if (previewPageImg) previewPageImg.src = hasPreview ? paginaPreview.preview : "";
      };

      const loadPreview = async () => {
        try {
          const { data, error } = await supabase
            .from("pagina")
            .select("*")
            .limit(1)
            .maybeSingle();
          if (error) throw error;
          paginaPreview = data || null;
          renderPreview();
        } catch (err) {
          console.error("load preview error", err);
          setPreviewStatus("No se pudo cargar el preview.", true);
        }
      };

      const renderIconosGallery = (items = []) => {
        if (!iconosGalleryEl) return;
        const rows = Array.isArray(items)
          ? items
              .filter((it) => it?.publicUrl)
              .filter((it) => !String(it?.name || "").startsWith("."))
              .filter((it) => isImageName(it?.name))
          : [];
        if (!rows.length) {
          iconosGalleryEl.innerHTML = '<p class="status icono-empty">Sin iconos cargados.</p>';
          return;
        }
        iconosGalleryEl.innerHTML = rows
          .map(
            (item) => `
              <figure class="icono-item" title="${escapeHtml(item.name || "")}">
                <img src="${escapeHtml(item.publicUrl)}" alt="${escapeHtml(item.name || "icono")}" loading="lazy" decoding="async" />
                <figcaption>${escapeHtml(item.name || "")}</figcaption>
              </figure>
            `,
          )
          .join("");
      };

      const loadIconos = async () => {
        try {
          const url = new URL(`${API_BASE}/api/logos/list`);
          url.searchParams.set("folder", "icono-perfil");
          if (sessionId) url.searchParams.set("id_usuario", String(sessionId));
          const res = await fetch(url.toString(), {
            credentials: "include",
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok) {
            throw new Error(data?.error || "No se pudo listar iconos.");
          }
          renderIconosGallery(data?.items || []);
        } catch (err) {
          console.error("load iconos error", err);
          renderIconosGallery([]);
          setIconosStatus("No se pudieron cargar los iconos.", true);
        }
      };

      const loadPlataformas = async () => {
        try {
          const { data, error } = await supabase
            .from("plataformas")
            .select("id_plataforma, nombre, imagen, banner")
            .order("nombre", { ascending: true });
          if (error) throw error;
          plataformasMap = (data || []).reduce((acc, p) => {
            acc[p.id_plataforma] = p;
            return acc;
          }, {});
          if (selectPlataforma) {
            selectPlataforma.innerHTML =
              '<option value="">Seleccione una plataforma</option>' +
              (data || [])
                .map((p) => `<option value="${p.id_plataforma}">${p.nombre}</option>`)
                .join("");
          }
        } catch (err) {
          console.error("load plataformas error", err);
          setStatus("No se pudieron cargar las plataformas.", true);
        }
      };

      selectPlataforma?.addEventListener("change", () => {
        const val = selectPlataforma.value;
        selectedId = val ? Number(val) : null;
        setStatus("");
        setBannerStatus("");
        setPreviewStatus("");
        if (fileInput) fileInput.value = "";
        if (bannerInput) bannerInput.value = "";
        const plat = selectedId ? plataformasMap[selectedId] : null;
        renderEditor(plat);
      });

      previewToggleBtn?.addEventListener("click", () => {
        if (!previewEditor) return;
        previewEditor.classList.toggle("hidden");
      });

      iconosToggleBtn?.addEventListener("click", async () => {
        if (!iconosEditor) return;
        const willOpen = iconosEditor.classList.contains("hidden");
        iconosEditor.classList.toggle("hidden");
        if (willOpen) {
          setIconosStatus("");
          await loadIconos();
        }
      });

      btnIconosUpload?.addEventListener("click", async () => {
        const selected = Array.from(iconosFilesInput?.files || []);
        if (!selected.length) {
          setIconosStatus("Selecciona una carpeta o varias imágenes.", true);
          return;
        }
        const files = selected.filter((file) => isImageFile(file));
        if (!files.length) {
          setIconosStatus("No se encontraron imágenes válidas en la selección.", true);
          return;
        }
        try {
          const batchSize = 20;
          let uploadedCount = 0;
          for (let i = 0; i < files.length; i += batchSize) {
            const chunk = files.slice(i, i + batchSize);
            const processed = Math.min(i + chunk.length, files.length);
            setIconosStatus(`Subiendo iconos (${processed}/${files.length})...`);
            const { urls, error: uploadErr } = await uploadPlatformLogos(chunk, {
              folder: "icono-perfil",
            });
            if (uploadErr) throw uploadErr;
            uploadedCount += Array.isArray(urls) ? urls.length : 0;
          }
          if (!uploadedCount) throw new Error("No se subieron iconos.");
          const skipped = selected.length - files.length;
          const extraText = skipped > 0 ? ` Se omitieron ${skipped} archivos no válidos.` : "";
          setIconosStatus(`Se subieron ${uploadedCount} iconos correctamente.${extraText}`);
          if (iconosFilesInput) iconosFilesInput.value = "";
          await loadIconos();
        } catch (err) {
          console.error("subir iconos error", err);
          setIconosStatus("No se pudieron subir los iconos.", true);
        }
      });

      btnUpdate?.addEventListener("click", async () => {
        if (!selectedId) {
          setStatus("Selecciona una plataforma.", true);
          return;
        }
        let file = fileInput?.files?.[0];
        if (!file) {
          setStatus("Selecciona una imagen.", true);
          return;
        }
        if (!file.type?.startsWith("image/")) {
          setStatus("Solo se permiten archivos de imagen.", true);
          return;
        }
        try {
          console.log("[editar_logos] selectedId", selectedId);
          console.log("[editar_logos] file", { name: file.name, type: file.type, size: file.size });
          setStatus("Optimizando imagen...");
          file = await resizeImageIfNeeded(file);
          console.log("[editar_logos] optimized file", { name: file.name, type: file.type, size: file.size });
          setStatus("Subiendo logo...");
          const { urls, error: uploadErr } = await uploadPlatformLogos([file]);
          console.log("[editar_logos] upload response", { urls, uploadErr });
          if (uploadErr) throw uploadErr;
          const url = urls?.[0];
          if (!url) throw new Error("No se obtuvo URL del logo.");
          console.log("[editar_logos] updating plataforma imagen", { id_plataforma: selectedId, url });
          const { error: updErr } = await supabase
            .from("plataformas")
            .update({ imagen: url })
            .eq("id_plataforma", selectedId);
          console.log("[editar_logos] update response", { updErr });
          if (updErr) throw updErr;
          plataformasMap[selectedId] = {
            ...plataformasMap[selectedId],
            imagen: url,
          };
          renderEditor(plataformasMap[selectedId]);
          setStatus("Logo actualizado correctamente.");
          if (fileInput) fileInput.value = "";
        } catch (err) {
          console.error("actualizar logo error", err);
          setStatus("No se pudo actualizar el logo.", true);
        }
      });

      btnBannerUpdate?.addEventListener("click", async () => {
        if (!selectedId) {
          setBannerStatus("Selecciona una plataforma.", true);
          return;
        }
        let file = bannerInput?.files?.[0];
        if (!file) {
          setBannerStatus("Selecciona una imagen.", true);
          return;
        }
        if (!file.type?.startsWith("image/")) {
          setBannerStatus("Solo se permiten archivos de imagen.", true);
          return;
        }
        try {
          console.log("[editar_logos] banner selectedId", selectedId);
          console.log("[editar_logos] banner file", { name: file.name, type: file.type, size: file.size });
          setBannerStatus("Optimizando imagen...");
          file = await resizeBannerIfNeeded(file);
          console.log("[editar_logos] optimized banner file", { name: file.name, type: file.type, size: file.size });
          setBannerStatus("Subiendo banner...");
          const { urls, error: uploadErr } = await uploadPlatformLogos([file]);
          console.log("[editar_logos] banner upload response", { urls, uploadErr });
          if (uploadErr) throw uploadErr;
          const url = urls?.[0];
          if (!url) throw new Error("No se obtuvo URL del banner.");
          console.log("[editar_logos] updating plataforma banner", { id_plataforma: selectedId, url });
          const { error: updErr } = await supabase
            .from("plataformas")
            .update({ banner: url })
            .eq("id_plataforma", selectedId);
          console.log("[editar_logos] banner update response", { updErr });
          if (updErr) throw updErr;
          plataformasMap[selectedId] = {
            ...plataformasMap[selectedId],
            banner: url,
          };
          renderEditor(plataformasMap[selectedId]);
          setBannerStatus("Banner actualizado correctamente.");
          if (bannerInput) bannerInput.value = "";
        } catch (err) {
          console.error("actualizar banner error", err);
          setBannerStatus("No se pudo actualizar el banner.", true);
        }
      });

      btnPreviewUpdate?.addEventListener("click", async () => {
        let file = previewInput?.files?.[0];
        if (!file) {
          setPreviewStatus("Selecciona una imagen.", true);
          return;
        }
        if (!file.type?.startsWith("image/")) {
          setPreviewStatus("Solo se permiten archivos de imagen.", true);
          return;
        }
        try {
          setPreviewStatus("Optimizando imagen...");
          file = await resizePreviewIfNeeded(file);
          setPreviewStatus("Subiendo preview...");
          const { urls, error: uploadErr } = await uploadPlatformLogos([file]);
          if (uploadErr) throw uploadErr;
          const url = urls?.[0];
          if (!url) throw new Error("No se obtuvo URL del preview.");
          const fallbackLogo =
            document.querySelector(".logo")?.src ||
            "https://ojigtjcwhcrnawdbtqkl.supabase.co/storage/v1/object/public/public_assets/logos/moose.png";
          const row =
            paginaPreview ||
            (await supabase.from("pagina").select("*").limit(1).maybeSingle()).data;
          if (!row) {
            const { error: insErr } = await supabase
              .from("pagina")
              .insert({ preview: url, logo: fallbackLogo });
            if (insErr) throw insErr;
          } else {
            let query = supabase.from("pagina").update({ preview: url });
            const idKey = Object.keys(row).find(
              (k) => k === "id" || k.startsWith("id_"),
            );
            if (idKey && row[idKey] != null) {
              query = query.eq(idKey, row[idKey]);
            } else {
              // Fallback para tablas sin PK: aplica WHERE para evitar error 21000
              query = query.or("preview.is.null,preview.not.is.null");
            }
            const { error: updErr } = await query;
            if (updErr) throw updErr;
          }
          paginaPreview = { ...(row || {}), preview: url };
          renderPreview();
          setPreviewStatus("Preview actualizado correctamente.");
          if (previewInput) previewInput.value = "";
        } catch (err) {
          console.error("actualizar preview error", err);
          setPreviewStatus("No se pudo actualizar el preview.", true);
        }
      });

      async function init() {
        try {
          if (sessionId) {
            const ss = await startSession(sessionId);
            console.log("[editar_logos] startSession", ss);
          }
          const user = await loadCurrentUser();
          if (user && usernameEl) {
            const fullName = [user.nombre, user.apellido].filter(Boolean).join(" ").trim();
            usernameEl.textContent = fullName || user.correo || "Usuario";
          }
          const isAdmin = isTrue(user?.permiso_admin) || isTrue(user?.permiso_superadmin);
          if (adminLink) {
            adminLink.classList.toggle("hidden", !isAdmin);
            adminLink.style.display = isAdmin ? "block" : "none";
          }
          if (!isAdmin) {
            setStatus("No tienes permisos para administrar servicios.", true);
          }
        } catch (err) {
          console.error("editar logos init error", err);
        }
      }

      init();
      loadPlataformas();
      loadPreview();
      attachLogout(clearServerSession);
    </script>
  </body>
</html>
